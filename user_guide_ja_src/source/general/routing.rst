################
URI ルーティング
################

通常は URL の文字列と関連するコントローラのクラス/メソッドには一対一の
関係があります。 URI
の中のセグメントは通常下記のようなパターンになっています:


::

	example.com/class/function/id/


しかし、URL が表すものが呼ばれる代わりに、 異なるクラス/メソッドが呼ば
れるように関連付けを再マッピングしたい場合もあるかと思います。

たとえば、次のような例の URL にしたい時:

example.com/product/1/
example.com/product/2/
example.com/product/3/
example.com/product/4/

通常は、URL の第2セグメントはメソッド名として予約されていますが、上の
例では、代わりに商品 ID になっています。
これに対応するため、CodeIgniter では URI ハンドラ [ 訳注: URI
に関連付けられたコントローラ/メソッドのこと ]
を再マッピングすることが可能です。



ユーザ定義のルーティングを設定する
==================================

ルーティング(経路制御)ルールは application/config/routes.php
ファイルで定義されています。その中に $route という名前の配列があると思
いますが、ここでユーザ定義のルーティング条件を指定することができます。
ルート(経路)は、 ワイルドカード または 正規表現
のどちらかを使って指定できます。



ワイルドカード
==============

ワイルドカードを使った典型的なルート(経路)指定は次のような感じになりま
す:


::

	$route['product/:num'] = "catalog/product_lookup";


ルートの中で、配列のキーはマッチさせる URI
で、一方の配列の値は再ルート先になります。 上の例では、リテラルの
"product" が URL
の第1セグメントに、数字が第2セグメントにそれぞれ設定されていた場合、
"catalog" クラスの "product_lookup"
メソッドが通常のルールの代わりに使用されることになります。

リテラル値または次の2種類のワイルドカードを使ってマッチさせることがで
きます:

(:num) は、セグメントが数字のみを含む場合にマッチします。
(:any) は、セグメントの中身が、どのような文字列でもマッチします。

.. note:: ルートは、定義されている順番にもとづいて実行されます。優先度が高いルートが、低いものより常に先に来るようにします。



例
==

ルーティングについて、いくつか例を挙げます:


::

	$route['journals'] = "blogs";


URL の第1セグメントに "journals" という語を含む URL は、"blogs"
クラスに再マッピングされます。


::

	$route['blog/joe'] = "blogs/users/34";


blog/joe というセグメントが含まれる URL は、"blogs" クラスの "users"
メソッドに再マッピングされます。ID は"34"にセットされます。


::

	$route['product/(:any)'] = "catalog/product_lookup";


第1セグメントが "product" 第2セグメントに何かが設定された URL
であれば、"catalog" クラスの "product_lookup"
メソッドに再マッピングされます。


::

	$route['product/(:num)'] = "catalog/product_lookup_by_id/$1";


第1セグメントが "product" 第2セグメントに数値が設定された URL
であれば、"catalog" クラスの "product_lookup_by_id"
メソッドにマッチした値を変数として再マッピングされます。

重要: マッチさせるワードには、先頭および末尾にスラッシュ ( "/" )
をつけてはいけません。



正規表現
========

ルーティングルールに正規表現を使うこともできます。正しい正規表現であれ
ば後方参照(戻り参照)
のようなものであっても、どんなものも使用できます。

.. note:: 後方参照(戻り参照)を使うときは、ダブルバックスラッシュ ( "\\" )を使った構文ではなく、ドル記号 ( "$" ) を使う構文で指定してください。

正規表現を使った典型的なルート指定は次のような感じになります:


::

	$route['products/([a-z]+)/(\d+)'] = "$1/id_$2";


上の例では、 products/shirts/123 のような URI
は、通常のルールの代わりに、 shirts コントローラクラスの id_123
メソッドが呼ばれます。

また、正規表現にワイルドカードを混在させてマッチさせることもできます。



予約済みのルート
================

予約済みのルートが2つあります:


::

	$route['default_controller'] = 'welcome';


このルートは URI がデータを含まない時に、どのコントローラを呼ぶべきか
を指定するものです。 上の例では、"welcome" クラスがロードされます。デ
フォルトルートは常に設定しておくことをおすすめします。
そうしておかないと、デフォルトで404ページが表示されてしまいます。


::

	$route['404_override'] = '';


このルートはリクエストされたコントローラが見つからない場合に、どのコン
トローラを呼ぶべきかを指定するものです。この指定はデフォルトの404ペー
ジを 上書きします。 application/errors/error_404.php
にあるデフォルトの error_404.php ファイルを読み込む show_404()
関数には影響しません。

重要: 予約されたルートは、正規表記のルートか、任意のワイルドカードの前
にこなければいけません。

