############
コントローラ
############

コントローラは、HTTP リクエストがどのように扱われるかを決定するので、
アプリケーションの心臓部だといえます。


-  コントローラとは？
-  Hello World
-  メソッド
-  URI セグメントのメソッドへの引渡し
-  デフォルトコントローラの定義
-  メソッド呼び出しの再マッピング
-  出力データのコントロール
-  Private なメソッド
-  サブフォルダへのコントローラの配置
-  クラスのコンストラクタ
-  予約済みのメソッド名




コントローラとは？
==================

コントローラは、名前が URI に関連付けられたクラスファイルです。

次のような URI があったとします:


::

	example.com/index.php/blog/


上の例では、CodeIgniter は blog.php
という名前のコントローラを探して読み込もうとします。

コントローラの名前がURIの最初のセグメントに一致した場合、それが読み込
まれます。



やってみよう: Hello World!
==========================

簡単なコントローラを作って、実際に動作を見てみましょう。
テキストエディタを使って、 blog.php
というファイルを作成し、次のコードを中に書きます:


::

	
	<?php
	class Blog extends CI_Controller {
	
		public function index()
		{
			echo 'Hello World!';
		}
	}
	?>


そして、 application/controllers/ フォルダにファイルを保存します。

保存し終わったら、次のような URL を使ってサイトを訪問してみましょう:


::

	example.com/index.php/blog/


正しく行えば、 Hello World! と見えているはずです。

.. note:: クラス名は、必ず大文字から始めなくてはいけません。つまり、以下は正しい例になります:


::

	<?php
	class Blog extends CI_Controller {
	
	}
	?>


次の例は 正しくありません :


::

	<?php
	class blog extends CI_Controller {
	
	}
	?>


また、コントローラは、親のコントローラクラスを継承( extends )するのを
忘れないでください。そうすることで親クラスのメソッドがすべて継承されま
す。



メソッド
========

上の例では、メソッド名は index() になっています。"index"メソッドは、デ
フォルトでは、第2セグメントが空のときに常に呼ばれるメソッドになります
。 下で例示している方法は、"Hello World"
メッセージを表示させるもうひとつの方法になります:


::

	example.com/index.php/blog/index/


URI の第2セグメントは、コントローラ内のどのメソッドが呼ばれるかを決め
ます。

コントローラに新しいメソッドを追加してみましょう。:


::

	
	<?php
	class Blog extends CI_Controller {
	
		public function index()
		{
			echo 'Hello World!';
		}
	
		public function comments()
		{
			echo 'Look at this!';
		}
	}
	?>


さて、 comment メソッドを見るため、次の URL を読み込んでみます:


::

	example.com/index.php/blog/comments/


新しいメッセージを見ることができるはずです。



URI セグメントのメソッドへの引渡し
==================================

URL に3つ以上のセグメントが含まれる場合、3番目以降のセグメントは、メソ
ッドに引数として渡されます。

例として、次のような URI だったとします:


::

	example.com/index.php/products/shoes/sandals/123


URI の3番目と4番目のセグメント ("sandals"
と"123")がメソッドに渡されます:


::

	
	<?php
	class Products extends CI_Controller {
	
	    public function shoes($sandals, $id)
	    {
	        echo $sandals;
	        echo $id;
	    }
	}
	?>


重要: :doc:`URI ルーティング <routing>` 機能を使う場合、メソッドに渡さ
れるセグメントは、再ルーティングされた後のものになります。



デフォルトコントローラを定義する
================================

CodeIgniter には、サイトのルート URL がリクエストされる場合のように、
通常のコントローラとメソッドを指定するような URI
が表されていないときに、 ロードすべきデフォルトコントローラを設定でき
ます。デフォルトコントローラを指定するには、
application/config/routes.php ファイルを開き、
次の値をセットしてください:


::

	$route['default_controller'] = 'Blog';


この Blog は利用したいコントローラクラスの名前です。 URI
セグメントを指定せず、メインの index.php
をロードしたときデフォルトでは、Hello World メッセージが表示されます。



メソッド呼び出しの再マッピング
==============================

上記で述べたとおり、URI の第2セグメントは一般に、コントローラのどのメ
ソッドが呼ばれるかを決めているところですが、 CodeIgniter では _remap()
メソッドを利用することで、この振る舞いをオーバーライド(再定義)すること
ができます:


::

	public function _remap()
	{
	    // ここに何かのコード...
	}


重要: コントローラに _remap() という名前のメソッドが含まれる場合、
それは、URI に何がかかれていようが 常に 呼び出されます。 それは、どの
メソッドを呼ぶかを決めるという標準の振る舞いをオーバーライドするもので
、独自のメソッドルーティングルールを定義することができます。

オーバーライドされたメソッド呼び出し(通常は URI
の第2セグメントの文字列)は _remap() メソッドの引数として渡されます:


::

	public function _remap($method)
	{
	    if ($method == 'some_method')
	    {
	        $this->$method();
	    }
	    else
	    {
	        $this->default_method();
	    }
	}


メソッド名以降のセグメントは、オプションである第 2 引数として _remap()
メソッドに渡されます。この配列は、 PHP の `call_user_func_array
<http://php.net/call_user_func_array>`_
関数と組み合わせることで、CodeIgniter
のデフォルトの動作を指定するのに使うことができます。


::

	public function _remap($method, $params = array())
	{
	    $method = 'process_'.$method;
	    if (method_exists($this, $method))
	    {
	        return call_user_func_array(array($this, $method), $params);
	    }
	    show_404();
	}




出力を処理する
==============

CodeIgniter には、最終的にレンダリングされたデータを Web
ブラウザへ送信するのを自動的に取り扱う、出力 (Output)
クラスがあります。 :doc:`ビュー <views>` と :doc:`出力(Output)クラス
<../libraries/output>` の解説ページにより詳しい情報があります。 処理が
終わったデータを何らかの方法で事後処理し、自分でブラウザに送信したいと
きがあります。 CodeIgniter
では、最終処理された出力データを受け取ることができる _output()
という名前のメソッドをコントローラに追加することができます。

重要: コントローラに _output() という名前のメソッドが含まれるとき、そ
れは、処理済のデータが直接送出されるかわりに、 常に
出力(Output)クラスから呼ばれることになります。
メソッドの第1引数には、処理済データが入ります。

以下に例を示します:


::

	
	public function _output($output)
	{
	    echo $output;
	}


_output() メソッドではデータが処理済の状態で受け取られるということを注
意してください。 データを_output() メソッドで使う前に、ベンチマークや
メモリ使用量のデータはレンダリング済みで、 (キャッシュが有効な場合は)
キャッシュファイルも書き込まれています。ヘッダも送信済みです (
:doc:`該当機能 <../libraries/output>` を利用する場合）。

コントローラの出力を適切にキャッシュさせるために、 _output()
メソッドを使用できます:


::

	if ($this->output->cache_expiration > 0)
	{
	    $this->output->_write_cache($output);
	}

ページ実行タイマー機能やメモリ使用量の統計機能を使う場合、実行した追加
の処理は考慮されないので、完全に正確にはなりません。 他に
*最終処理の前に *出力をコントロールする方法については、
:doc:`出力(Output)クラス <../libraries/output>`
で利用可能なメソッドをご覧ください。



Private なメソッド
==================

パブリックなアクセスに対して、あるメソッドを隠したい場合があります。 
メソッドをプライベートにするには、単にアンダースコアを名前の先頭に付加
すれば、URL リクエストを経由して実行されなくなります。たとえば、次のよ
うなメソッドがあったとします:


::

	
	private function _utility()
	{
	  // 何かのコード
	}


次のような URL でアクセスしてみてください。これは機能しません:


::

	example.com/index.php/blog/_utility/




サブフォルダへのコントローラの配置
==================================

規模が大きいアプリケーションを構築するとき、探しやすいように、コントロ
ーラをサブフォルダに配置したいことがあります。CodeIgniter
ではこういったこともできます。

application/controllers ディレクトリの中に単純にフォルダを作成し、コン
トローラクラスをその中に配置します。

.. note:: この機能を使うと、URIの第1セグメントはフォルダを指すものになります。
たとえば、コントローラを次の場所に置いたとします:


::

	application/controllers/products/shoes.php


このコントローラを呼び出す URI は次のようになります:


::

	example.com/index.php/products/shoes/show/123


サブフォルダには、サブフォルダだけを指定した URL
のときに呼び出される、
デフォルトコントローラをそれぞれ置くことができます。
デフォルトコントローラの名前は、 application/config/routes.php
ファイルで指定した名前です。

また、CodeIgniter では、 :doc:`URI ルーティング <routing>`
機能を利用して、URI の再マッピングをすることができます。



クラスのコンストラクタ
======================

コンストラクタを使用する場合は、どのようなコントローラであるかにかかわ
らず 必ず 次の行をコードに配置する必要があります:


::

	parent::__construct();


ローカルなコンストラクタは、親コントローラクラスのコンストラクタを上書
きしてしまうので、手動で親コントローラクラスのコンストラクタを呼び出す
必要があるというのが、この行が必要な理由です。


::

	
	<?php
	class Blog extends CI_Controller {
	
	       public function __construct()
	       {
	            parent::__construct();
	            // これ以降にコードを書いていく
	       }
	}
	?>


コンストラクタは、インスタンス化されるときに初期値をセットする必要があ
る場合や、既定の処理を実行する場合に便利です。 コンストラクタは値を返
すことができませんが、既定の処理を実行することができます。



予約済みのメソッド名
====================

コントローラは、メインのアプリケーションコントローラから拡張されるので
、オーバーライドする場合を除き、 アプリケーションコントローラクラスで
使われているメソッドと同じ名前にしないよう注意してください。 詳細は、
:doc:`予約語一覧 <reserved_names>` を参照してください。



以上です!
=========

簡単ですが、これでコントローラについてすべてお知らせしました。

