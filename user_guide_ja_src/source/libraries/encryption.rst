############
暗号化クラス
############

暗号化クラスでは、2種類のデータ暗号化方式が提供されています。
一つは、ランダムなハッシュ値でメッセージの排他的ビット和 (bitwise XOR)
をプリコンパイルする方法、 もう一つは Mcrypt
ライブラリを使って暗号化する方式です。サーバで Mcrypt
が有効になっていない場合、
符号化されるメッセージは、セッションの暗号化などの "気軽な"
目的に適合する程度のセキュリティになります。 Mcrypt
が有効な場合は、保管に適した高いレベルのセキュリティを提供します。



キーの設定
==========

*キー* は、暗号化処理をコントロールし、暗号化された文字列を復号できる
小さな情報です。
実際には、選んだキーは、そのキーで暗号化されたデータを復号する 唯一の
手段になります。 ですので、注意してキーを選ぶだけでなく、保存用データ
に使用するつもりならキーは決して変更してはいけません。

言うまでもなく、キーは厳重に保管されるべきです。
誰かがキーを取得できてしまえば、データは簡単に復号されてしまいます。 
サーバが完全に管理できない場合は、クレジットカード番号を保管する場合な
どの高いセキュリティが必要とされるものに暗号化を適用する場合は、
常にキーの安全性を注意して考えるのを忘れないでください。

暗号アルゴリズムを最大限利用するには、キーは32文字の長さ(128
ビット)にする必要があります。 キーは、大文字小文字や数字をできる限りラ
ンダムに混合させる必要があります。 キーは単純な文字列に
してはいけません 。
暗号化を安全にするためには、可能な限りランダムにする必要があります。

キーは application/config/config.php
の中に保存するか、あるいは独自の保存方法を設計して、
暗号化/復号のときに動的にキーを渡すかのどちらかになります。

キーを application/config/config.php
に保存するには、ファイルを開き、下記のようにセットします:

::

	$config['encryption_key'] = "あなたのキー";




メッセージの長さ
================

暗号化メソッドで生成されたメッセージは元のメッセージより約2.6倍長くな
るということを知っておくのは重要です。 たとえば、21文字の "my super
secret data" という文字列を暗号化した場合は、暗号化された文字列は、お
よそ55文字になります (暗号化された文字列は、64ビットのクラスタごとに長
さが増加し、正確にはリニアに増加しないので、「およそ」になります)。
データの保管方式を選ぶ際に、このことを考慮するようにしてください。
たとえば、クッキーは4 KB のデータしか保持できません。



クラスの初期化
==============

CodeIgniter
の大部分のクラスと同じく、暗号化クラスは、コントローラの中で
$this->load->library メソッドを使用することで初期化できます:


::

	$this->load->library('encrypt');


いったん読み込まれると、暗号化ライブラリオブジェクトは、次のようにして
利用可能です: $this->encrypt



$this->encrypt->encode()
========================

データを暗号化し、文字列として返します。例:

::

	
	$msg = 'My secret message';
	
	$encrypted_string = $this->encrypt->encode($msg);


設定ファイルに指定してあるキーを使用したくない場合は、オプションで、第
2引数に暗号化キーを指定することができます:


::

	
	$msg = '秘密のメッセージ';
	$key = '最高機密のキー';
	
	$encrypted_string = $this->encrypt->encode($msg, $key);




$this->encrypt->decode()
========================

暗号化された文字列を復号します。例:


::

	
	$encrypted_string = 'APANtByIGI1BpVXZTJgcsAG8GZl8pdwwa84';
	
	$plaintext_string = $this->encrypt->decode($encrypted_string);


設定ファイルのキーを利用したくない場合は、第2引数で暗号化キーを渡す事
が出来ます。


::

	
	$msg = 'My secret message';
	$key = 'super-secret-key';
	
	$encrypted_string = $this->encrypt->decode($msg, $key);




$this->encrypt->set_cipher();
=============================

Mcryptの暗号アルゴリズムをセットできます。デフォルトでは、
MCRYPT_RIJNDAEL_256 を使用します。例:

::

	$this->encrypt->set_cipher(MCRYPT_BLOWFISH);


`利用できる暗号アルゴリズム <http://jp.php.net/mcrypt>`_
のリストを見るには、php.net を訪問してください。

サーバで Mcrypt がサポートされているかどうかを手動でテストしたい場合は
、以下のようにします:

::

	echo ( ! function_exists('mcrypt_encrypt')) ? 'NG' : 'OK';




$this->encrypt->set_mode();
===========================

Mcrypt のブロック暗号モードをセットできます。デフォルトでは、
MCRYPT_MODE_CBC を使います。例:

::

	$this->encrypt->set_mode(MCRYPT_MODE_CFB);


`利用できるモード <http://jp.php.net/mcrypt>`_ の一覧を見るには
php.net を訪問してください。



$this->encrypt->sha1();
=======================

SHA1 エンコードメソッド。文字列を渡すと160ビットの一方向ハッシュを返し
ます。Note: SHA1 はちょうど MD5 のように、復号できません。例:

::

	$hash = $this->encrypt->sha1('何かの文字列');


多くの PHP 環境では、SHA1 がデフォルトでサポートされていますので、 単
にエンコードすればよいだけであれば、組み込みの関数を利用すれば単純にな
ります:


::

	$hash = sha1('何かの文字列');


もしサーバが SHA1
をサポートしていなければ、このクラスのメソッドを使用できます。



$this->encrypt->encode_from_legacy( $orig_data , $legacy_mode =
MCRYPT_MODE_ECB, $key = '');
============================

CodeIgniter 1.x で暗号化したデータを、CodeIgniter 2.x
の暗号化クラスと互換性を持つように再エンコードできます。
データをファイルやデータベースに保存しており、サーバが Mcrypt
に対応していれば、このメソッドを使用できます。 セッションや一時的なデ
ータの暗号化程度の軽い利用なら、あなたの介入は必要ありません。
しかし、2.x 以前で暗号化されたデータは復号されないため、既存の暗号化セ
ッションは破棄されます。

なぜ古いメソッドのエンコードとデコードを維持せず、データの再エンコード
だけを? 暗号化クラスのアルゴリズムは、CodeIgniter 2.x
でパフォーマンスと安全性の両方が改善されました。
そして古いメソッドを引き続き使用することを推奨したくありません。 もち
ろん、あなたは暗号化ライブラリを編集して新しいメソッドを古いものに置き
換えることで、CodeIgniter 1.x で暗号化されたデータと互換性をもたせるこ
とはできますが、それは開発者が慎重に決定してください。


::

	$new_data = $this->encrypt->encode_from_legacy($old_encrypted_string);

 
パラメータ
	デフォルト
	説明
 $orig_data
	 なし
	 CodeIgniter 1.x の暗号化クラスで暗号化されたデータ
 $legacy_mode
	 MCRYPT_MODE_ECB
	 元のデータを暗号化する際に使用された Mcrypt のモード。CodeIgniter 1.x のデフォルトは MCRYPT_MODE_ECB でした。
		指定されなければそうみなします。
 $key
	 なし
	 暗号化キー。先に示したように、通常は設定ファイルで指定したもの。


